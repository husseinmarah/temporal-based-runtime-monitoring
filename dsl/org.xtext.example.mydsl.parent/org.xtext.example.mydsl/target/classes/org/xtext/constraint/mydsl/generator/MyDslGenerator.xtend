/*
 * generated by Xtext 2.26.0-SNAPSHOT
 */
package org.xtext.constraint.mydsl.generator
import at.jku.se.mosumo.dronology.constraint.esper.EsperEngine
import at.jku.se.mosumo.dronology.constraint.esper.EsperPackage
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.constraint.mydsl.myDsl.PatternInitialization
import org.xtext.constraint.mydsl.myDsl.QueryInitialization
import org.xtext.constraint.mydsl.myDsl.ComplexInitialization

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyDslGenerator extends AbstractGenerator {

	def initEMF() {
		EPackage.Registry.INSTANCE.put(EsperPackage.eINSTANCE.nsURI, EsperPackage.eINSTANCE)
		Resource.Factory.Registry.INSTANCE.extensionToFactoryMap.put("xmi", new XMIResourceFactoryImpl);
		// Obtain a new resource set
		val ResourceSet rset = new ResourceSetImpl();
		// Get the resource
		val Resource rs = rset.getResource(
			URI.createURI("file:///C:/Users/Hussein/eclipse-workspace-dsl-demo/org.xtext.example.mydsl.parent/at.jku.se.mosumo.dronology.constraint.esper/model/EsperEngine3.xmi"),
			true);
		return rs;
	}

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val rs = initEMF()
		val root2 = rs.allContents.toIterable.filter(EsperEngine)
		for (root : resource.allContents.toIterable.filter(PatternInitialization)) {
			if (root !== null)
				fsa.generateFile(root.name + ".java", compileRealTimeConstraint(root, root2))
		}

		for (root : resource.allContents.toIterable.filter(QueryInitialization)) {
			if (root !== null)
				fsa.generateFile(root.name + ".java", compileSimpleConstraint(root, root2))
		}
		
				for (root : resource.allContents.toIterable.filter(ComplexInitialization)) {
			if (root !== null)
				fsa.generateFile(root.name + ".java", compileComplexConstraint(root, root2))
		}
	}

	def static compile(EsperEngine pattern) '''
		«FOR element : pattern.constraint»
			«element.event.name.toFirstUpper»
		«ENDFOR»
	'''

	def static compileSimpleConstraint(QueryInitialization query, Iterable<EsperEngine> esperEngine) '''
		«var eventName=""»
		«FOR element : esperEngine»
			«FOR e : element.constraint»
				«IF e.name == query.name»/* ..«eventName=e.event.name.toFirstUpper+"Event"».. */«ENDIF»
			«ENDFOR»
		   «ENDFOR»
		   «IF query.eContainer !== null»
			«val inputValue=query.inputStatements.value»
			select * from «eventName»(«query.inputStatements.property» «query.inputStatements.comparisonOperator» «IF inputValue.numberLiteral !== null»«inputValue.numberLiteral.value»«ENDIF»«IF inputValue.stringLiteral !== null»«inputValue.stringLiteral.value»«ENDIF»«IF inputValue.textLiteral !== null»«inputValue.textLiteral.value»«ENDIF»)
			«IF query.timeWindow !== null»
			#time(«query.timeWindow.time» «query.timeWindow.timeUnit»)	
			«ENDIF»
			«ENDIF»
	'''
	
		def static compileComplexConstraint(ComplexInitialization complex, Iterable<EsperEngine> esperEngine) '''
		«var eventName=""»
		«var eventCounter=1»
		«val patternStatement=complex.complexPatternStatements.complexPatternType»
		«FOR element : esperEngine»
			«FOR e : element.constraint»
				«IF e.name == complex.name»/* ..«eventName=e.event.name.toFirstUpper+"Event"».. */«ENDIF»
			«ENDFOR»
		   «ENDFOR»
		   «IF complex.eContainer !== null»
			select * from «eventName»«IF complex.timeWindow !== null»#time(«complex.timeWindow.time» «complex.timeWindow.timeUnit»)«ENDIF»
			match_recognize (
			measures «FOR element : complex.inputStatements SEPARATOR ', '»«element.name» as «element.property»«ENDFOR»
			pattern ( «patternStatement.firstEvent.name»«IF patternStatement.greedyQuantifiers.toString=='ZeroOrMore'»* «ENDIF»«IF patternStatement.greedyQuantifiers.toString=='OneOrMore'»+ «ENDIF»«IF patternStatement.greedyQuantifiers.toString=='ZeroOrOne'»? «ENDIF»
			«FOR element : patternStatement.complexPatternOptions»«element.seceondEvent.name»«IF element.greedyQuantifiers.toString=='ZeroOrMore'»* «ENDIF»«IF element.greedyQuantifiers.toString=='OneOrMore'»+ «ENDIF»«IF element.greedyQuantifiers.toString=='ZeroOrOne'»? «ENDIF»«ENDFOR» )
			define
			«FOR element : complex.inputStatements SEPARATOR ','»
			«val inputValue=element.value»
			«element.name» as «element.name».«element.property» «element.comparisonOperator» «IF inputValue.numberLiteral !== null»«inputValue.numberLiteral.value»«ENDIF»«IF inputValue.stringLiteral !== null»«inputValue.stringLiteral.value»«ENDIF»«IF inputValue.textLiteral !== null»«inputValue.textLiteral.value»«ENDIF»
			«ENDFOR» )
			«ENDIF»
	'''

	def static compileRealTimeConstraint(PatternInitialization pattern, Iterable<EsperEngine> esperEngine) '''
		«var i=0»
		«var eventName=""»
		«FOR element : esperEngine»
			«FOR e : element.constraint»
				«IF e.name == pattern.name»/* ..«eventName=e.event.name.toFirstUpper+"Event"».. */«ENDIF»
			«ENDFOR»
		   «ENDFOR» 
		«val firstEvent=pattern.patternStatements.patternType.firstEvent»
		«IF pattern.eContainer !== null»
			select * from pattern [
			every 
			«firstEvent.name» = «eventName» («firstEvent.property» «firstEvent.comparisonOperator» «IF firstEvent.value.numberLiteral !== null»«firstEvent.value.numberLiteral.value»«ENDIF»«IF firstEvent.value.stringLiteral !== null»«firstEvent.value.stringLiteral.value»«ENDIF»«IF firstEvent.value.textLiteral !== null»«firstEvent.value.textLiteral.value»«ENDIF»)
			 -> 
			«FOR inputs : pattern.patternStatements.patternType.patternOptions SEPARATOR '\n ->'»
				«val atLeast=inputs.occurenceAtLeast»
				«val atMost=inputs.occurenceAtMost»
				«val atNotSpecific=inputs.occurenceAtNotSpecificTime»
				«IF atLeast!==null»
					timer:interval(«atLeast.minDuration.time» «atLeast.minDuration.timeUnit»)
					 ->
					«atLeast.seceondEvent.name»	= «eventName» («atLeast.seceondEvent.property» «atLeast.seceondEvent.comparisonOperator»«IF atLeast.seceondEvent.value.numberLiteral !== null»«atLeast.seceondEvent.value.numberLiteral.value»«ENDIF»«IF atLeast.seceondEvent.value.stringLiteral !== null»«atLeast.seceondEvent.value.stringLiteral.value»«ENDIF»«IF atLeast.seceondEvent.value.textLiteral !== null»«atLeast.seceondEvent.value.textLiteral.value»«ENDIF» )
				«ENDIF»	
				«IF atMost!==null»
					«atMost.seceondEvent.name» = «eventName» («atMost.seceondEvent.property» «atMost.seceondEvent.comparisonOperator» «IF atMost.seceondEvent.value.numberLiteral !== null»«atMost.seceondEvent.value.numberLiteral.value»«ENDIF»«IF atMost.seceondEvent.value.stringLiteral !== null»«atMost.seceondEvent.value.stringLiteral.value»«ENDIF»«IF atMost.seceondEvent.value.textLiteral !== null»«atMost.seceondEvent.value.textLiteral.value»«ENDIF» )
					where timer:within(«atMost.maxDuration.time» «atMost.maxDuration.timeUnit»)
				«ENDIF»
				«IF atNotSpecific!==null»
					«atNotSpecific.seceondEvent.name» = «eventName» («atNotSpecific.seceondEvent.property» «atNotSpecific.seceondEvent.comparisonOperator» «IF atNotSpecific.seceondEvent.value.numberLiteral !== null»«atNotSpecific.seceondEvent.value.numberLiteral.value»«ENDIF»«IF atNotSpecific.seceondEvent.value.stringLiteral !== null»«atNotSpecific.seceondEvent.value.stringLiteral.value»«ENDIF»«IF atNotSpecific.seceondEvent.value.textLiteral !== null»«atNotSpecific.seceondEvent.value.textLiteral.value»«ENDIF»)
				«ENDIF»
			«ENDFOR» ]
		«ENDIF»       
	'''
}
